package tpls

import (
	"bytes"
	"fmt"
	"text/template"
)

const EntityTypeDefCodes = `// Code generated by go2gen. DO NOT EDIT.

package %s

import (
	"encoding/json"

    "{{.ProjectName}}/common/tools/tool_slice"
)
`

const entityTypeDef = `

func (e *{{$.EntityName}}) String() string {
	data, _ := json.Marshal(e)
	return string(data)
}

func (e *{{$.EntityName}}) EntityName() string {
	return "{{$.EntityName}}"
}

func (e *{{$.EntityName}}) ModifyDBMap(e2 *{{$.EntityName}},fields []string) map[string]interface{} {
	if e == nil || e2 == nil || fields == nil {
		return nil
	}
	tmp := make(map[string]interface{})
	{{- range $field := .Field}}
		{{- if ne $field.DBTag ""}} 
			{{- if $field.UseJSON}}
			if b,err := json.Marshal(e2.{{$field.Field}});err == nil {
				tmp["{{$field.DBTag}}"] = b
			}
			{{- else}}
			tmp["{{$field.DBTag}}"] = e2.{{$field.Field}}
			{{- end}}
		{{- end}}
	{{- end}}
	output := make(map[string]interface{})
	for _, field := range fields {
		if v, ok := tmp[field]; ok {
			output[field] = v
		}
	}
	return output
}

func (e *{{$.EntityName}}) ToTagMap(tagName string) map[string]interface{} {
	out := make(map[string]interface{})
	v := reflect.ValueOf(e)
	t := v.Type()
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		name := field.Name
		val := v.FieldByName(name)
		res := strings.Split(field.Tag.Get(tagName), ",")
		_tagName := res[0]
		if _tagName != "" {
			name = _tagName
			if strings.Contains(_tagName, ";") {
				name = strings.Split(_tagName, ";")[0]
			}
		}
		out[name] = val.Interface()
	}
	return out
}

type {{.EntityListName}} []*{{.EntityName}}

func (list {{$.EntityListName}}) String() string {
	data, _ := json.Marshal(list)
	return string(data)
}

{{range $field := .Field}}{{if $field.GenSliceFunc}}func (list {{$.EntityListName}}) Get{{$field.Field}}List() []{{$field.Type}} {
	return list.Get{{$field.TypeInName}}List(func (item *{{$.EntityName}}) {{$field.Type}} {
		return {{$field.FieldAccess "item"}}
	})
}{{end}}
{{end}}

{{range $field := .Field}}{{if $field.GenSliceFunc}}func (list {{$.EntityListName}}) GetMissing{{$field.Field}}List(input []{{$field.Type}}) []{{$field.Type}} {
    result := make([]{{$field.Type}}, 0)
	mapping := list.Get{{$field.Field}}Map()
    for _, item := range tool_slice.Unique{{$field.TypeInName}}Slice(input) {
        if mapping[item] == nil {
            result = append(result, item)
        }
    }
    return result
}{{end}}
{{end}}

{{range $field := .Field}}{{if $field.GenSliceFunc}}func (list {{$.EntityListName}}) FilterBy{{$field.Field}}(needle ...{{$field.Type}}) {{$.EntityListName}} {
	if len(needle) == 0 {
		return list
	}

	return list.FilterBy(func (item *{{$.EntityName}}) bool {
		for _, v := range needle {
			if {{$field.FieldAccess "item"}} == v {
                return true
            }
        }
		return false
    })
}{{end}}
{{end}}

{{range $field := .Field}}{{if $field.GenSliceFunc}}func (list {{$.EntityListName}}) GroupBy{{$field.Field}}() map[{{$field.Type}}]{{$.EntityListName}} {
	return list.GroupBy{{$field.TypeInName}}(func (item *{{$.EntityName}}) {{$field.Type}} {
		return {{$field.FieldAccess "item"}}
    })
}{{end}}
{{end}}

{{range $field := .Field}}{{if $field.GenSliceFunc}}func (list {{$.EntityListName}}) Get{{$field.Field}}Map() map[{{$field.Type}}]*{{$.EntityName}} {
	result := make(map[{{$field.Type}}]*{{$.EntityName}})
	for _, item := range list {
		result[{{$field.FieldAccess "item"}}] = item
	}
	return result
}{{end}}
{{end}}

func (list {{.EntityListName}}) GetStringList(visitor func(item *{{.EntityName}}) string)[]string {
	result := make([]string, 0, len(list))
	for _, item := range list {
		result = append(result, visitor(item))
	}
	return result
}

func (list {{.EntityListName}}) GetIntList(visitor func(item *{{.EntityName}}) int) []int {
	result := make([]int, 0, len(list))
	for _, item := range list {
		result = append(result, visitor(item))
	}
	return result
}

func (list {{.EntityListName}}) GetInt32List(visitor func(item *{{.EntityName}}) int32) []int32 {
	result := make([]int32, 0, len(list))
	for _, item := range list {
		result = append(result, visitor(item))
	}
	return result
}

func (list {{.EntityListName}}) GetInt64List(visitor func(item *{{.EntityName}}) int64) []int64 {
	result := make([]int64, 0, len(list))
	for _, item := range list {
		result = append(result, visitor(item))
	}
	return result
}

func (list {{.EntityListName}}) FilterBy(visitor func(item *{{.EntityName}}) bool) {{.EntityListName}} {
	result := make({{.EntityListName}}, 0, len(list))
	for _, item := range list {
		if visitor(item) {
			result = append(result, item)
		}
	}
	return result
}

func (list {{.EntityListName}}) GroupByString(visitor func(item *{{.EntityName}}) string) map[string]{{.EntityListName}} {
	result := make(map[string]{{.EntityListName}})
	for _, item := range list {
		key := visitor(item)
		result[key] = append(result[key], item)
	}
	return result
}

func (list {{.EntityListName}}) GroupByInt(visitor func(item *{{.EntityName}}) int) map[int]{{.EntityListName}} {
	result := make(map[int]{{.EntityListName}})
	for _, item := range list {
		key := visitor(item)
		result[key] = append(result[key], item)
	}
	return result
}

func (list {{.EntityListName}}) GroupByInt32(visitor func(item *{{.EntityName}}) int32) map[int32]{{.EntityListName}} {
	result := make(map[int32]{{.EntityListName}})
	for _, item := range list {
		key := visitor(item)
		result[key] = append(result[key], item)
	}
	return result
}

func (list {{.EntityListName}}) GroupByInt64(visitor func(item *{{.EntityName}}) int64) map[int64]{{.EntityListName}} {
	result := make(map[int64]{{.EntityListName}})
	for _, item := range list {
		key := visitor(item)
		result[key] = append(result[key], item)
	}
	return result
}
`

type EntityTypeMap struct {
	ProjectName    string
	EntityName     string
	EntityListName string
	Field          []Field
	HasCreator     bool
	CreatorName    string
}

type Field struct {
	Field           string
	FieldTag        string
	FieldEscapedTag string
	FieldTagMap     map[string]string
	DBTag           string
	Type            string
	UseJSON         bool
	NamedType       string
	TypeInName      string
	GenSliceFunc    bool
	Nullable        bool
	Comparable      bool
}

func (f *Field) FieldAccess(s string) string {
	field := fmt.Sprintf("%s.%s", s, f.Field)
	if f.NamedType != f.Type {
		return fmt.Sprintf("%s(%s)", f.Type, field)
	}
	return field
}

func (s *EntityTypeMap) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)
	tmpl, err := template.New(s.EntityName + "TypeMap").Parse(entityTypeDef)
	if err != nil {
		return nil, err
	}
	if err := tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
